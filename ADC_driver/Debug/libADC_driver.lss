In archive libADC_driver.a:

ADC_prog.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         000005ac  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      0000095b  00000000  00000000  000005e0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.ADC_u16GetCurrentValue 00000016  00000000  00000000  00000f3b  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  6 .text.ADC_voidInit 0000008c  00000000  00000000  00000f51  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  7 .text.ADC_u16GetValue 0000009c  00000000  00000000  00000fdd  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  8 .text.ADC_voidSelectChannel 00000022  00000000  00000000  00001079  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  9 .text.ADC_voidStartConversion 00000036  00000000  00000000  0000109b  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 10 .text.__vector_16 00000082  00000000  00000000  000010d1  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 11 .bss.ADC_value 00000002  00000000  00000000  00001153  2**0
                  ALLOC

Disassembly of section .text.ADC_u16GetCurrentValue:

00000000 <ADC_u16GetCurrentValue>:

static u16 ADC_value;


u16 ADC_u16GetCurrentValue(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
	return ADC_value;
   8:	80 91 00 00 	lds	r24, 0x0000
   c:	90 91 00 00 	lds	r25, 0x0000


}
  10:	cf 91       	pop	r28
  12:	df 91       	pop	r29
  14:	08 95       	ret

Disassembly of section .text.ADC_voidInit:

00000000 <ADC_voidInit>:

static u16 ADC_value;


u16 ADC_u16GetCurrentValue(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
	return ADC_value;
   8:	a6 e2       	ldi	r26, 0x26	; 38
   a:	b0 e0       	ldi	r27, 0x00	; 0
   c:	e6 e2       	ldi	r30, 0x26	; 38
   e:	f0 e0       	ldi	r31, 0x00	; 0


}
  10:	80 81       	ld	r24, Z
  12:	88 60       	ori	r24, 0x08	; 8
  14:	8c 93       	st	X, r24
  16:	af e5       	ldi	r26, 0x5F	; 95
  18:	b0 e0       	ldi	r27, 0x00	; 0
  1a:	ef e5       	ldi	r30, 0x5F	; 95
  1c:	f0 e0       	ldi	r31, 0x00	; 0
  1e:	80 81       	ld	r24, Z
  20:	80 68       	ori	r24, 0x80	; 128
  22:	8c 93       	st	X, r24
  24:	a7 e2       	ldi	r26, 0x27	; 39
  26:	b0 e0       	ldi	r27, 0x00	; 0
  28:	e7 e2       	ldi	r30, 0x27	; 39
  2a:	f0 e0       	ldi	r31, 0x00	; 0
  2c:	80 81       	ld	r24, Z
  2e:	8f 77       	andi	r24, 0x7F	; 127
  30:	8c 93       	st	X, r24
  32:	a7 e2       	ldi	r26, 0x27	; 39
  34:	b0 e0       	ldi	r27, 0x00	; 0
  36:	e7 e2       	ldi	r30, 0x27	; 39
  38:	f0 e0       	ldi	r31, 0x00	; 0
  3a:	80 81       	ld	r24, Z
  3c:	80 64       	ori	r24, 0x40	; 64
  3e:	8c 93       	st	X, r24
  40:	a7 e2       	ldi	r26, 0x27	; 39
  42:	b0 e0       	ldi	r27, 0x00	; 0
  44:	e7 e2       	ldi	r30, 0x27	; 39
  46:	f0 e0       	ldi	r31, 0x00	; 0
  48:	80 81       	ld	r24, Z
  4a:	8f 7d       	andi	r24, 0xDF	; 223
  4c:	8c 93       	st	X, r24
  4e:	a6 e2       	ldi	r26, 0x26	; 38
  50:	b0 e0       	ldi	r27, 0x00	; 0
  52:	e6 e2       	ldi	r30, 0x26	; 38
  54:	f0 e0       	ldi	r31, 0x00	; 0
  56:	80 81       	ld	r24, Z
  58:	80 68       	ori	r24, 0x80	; 128
  5a:	8c 93       	st	X, r24
  5c:	a6 e2       	ldi	r26, 0x26	; 38
  5e:	b0 e0       	ldi	r27, 0x00	; 0
  60:	e6 e2       	ldi	r30, 0x26	; 38
  62:	f0 e0       	ldi	r31, 0x00	; 0
  64:	80 81       	ld	r24, Z
  66:	8b 7f       	andi	r24, 0xFB	; 251
  68:	8c 93       	st	X, r24
  6a:	a6 e2       	ldi	r26, 0x26	; 38
  6c:	b0 e0       	ldi	r27, 0x00	; 0
  6e:	e6 e2       	ldi	r30, 0x26	; 38
  70:	f0 e0       	ldi	r31, 0x00	; 0
  72:	80 81       	ld	r24, Z
  74:	82 60       	ori	r24, 0x02	; 2
  76:	8c 93       	st	X, r24
  78:	a6 e2       	ldi	r26, 0x26	; 38
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	e6 e2       	ldi	r30, 0x26	; 38
  7e:	f0 e0       	ldi	r31, 0x00	; 0
  80:	80 81       	ld	r24, Z
  82:	8e 7f       	andi	r24, 0xFE	; 254
  84:	8c 93       	st	X, r24
  86:	cf 91       	pop	r28
  88:	df 91       	pop	r29
  8a:	08 95       	ret

Disassembly of section .text.ADC_u16GetValue:

00000000 <ADC_u16GetValue>:

static u16 ADC_value;


u16 ADC_u16GetCurrentValue(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <ADC_u16GetValue+0x6>
   6:	0f 92       	push	r0
	return ADC_value;
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	8b 83       	std	Y+3, r24	; 0x03
   e:	a7 e2       	ldi	r26, 0x27	; 39


}
  10:	b0 e0       	ldi	r27, 0x00	; 0
  12:	e7 e2       	ldi	r30, 0x27	; 39
  14:	f0 e0       	ldi	r31, 0x00	; 0
  16:	80 81       	ld	r24, Z
  18:	80 7e       	andi	r24, 0xE0	; 224
  1a:	8c 93       	st	X, r24
  1c:	a7 e2       	ldi	r26, 0x27	; 39
  1e:	b0 e0       	ldi	r27, 0x00	; 0
  20:	e7 e2       	ldi	r30, 0x27	; 39
  22:	f0 e0       	ldi	r31, 0x00	; 0
  24:	90 81       	ld	r25, Z
  26:	8b 81       	ldd	r24, Y+3	; 0x03
  28:	89 2b       	or	r24, r25
  2a:	8c 93       	st	X, r24
  2c:	a6 e2       	ldi	r26, 0x26	; 38
  2e:	b0 e0       	ldi	r27, 0x00	; 0
  30:	e6 e2       	ldi	r30, 0x26	; 38
  32:	f0 e0       	ldi	r31, 0x00	; 0
  34:	80 81       	ld	r24, Z
  36:	80 64       	ori	r24, 0x40	; 64
  38:	8c 93       	st	X, r24
  3a:	e6 e2       	ldi	r30, 0x26	; 38
  3c:	f0 e0       	ldi	r31, 0x00	; 0
  3e:	80 81       	ld	r24, Z
  40:	82 95       	swap	r24
  42:	8f 70       	andi	r24, 0x0F	; 15
  44:	88 2f       	mov	r24, r24
  46:	90 e0       	ldi	r25, 0x00	; 0
  48:	81 70       	andi	r24, 0x01	; 1
  4a:	90 70       	andi	r25, 0x00	; 0
  4c:	00 97       	sbiw	r24, 0x00	; 0
  4e:	01 f0       	breq	.+0      	; 0x50 <ADC_u16GetValue+0x50>
  50:	a6 e2       	ldi	r26, 0x26	; 38
  52:	b0 e0       	ldi	r27, 0x00	; 0
  54:	e6 e2       	ldi	r30, 0x26	; 38
  56:	f0 e0       	ldi	r31, 0x00	; 0
  58:	80 81       	ld	r24, Z
  5a:	80 61       	ori	r24, 0x10	; 16
  5c:	8c 93       	st	X, r24
  5e:	1a 82       	std	Y+2, r1	; 0x02
  60:	19 82       	std	Y+1, r1	; 0x01
  62:	e4 e2       	ldi	r30, 0x24	; 36
  64:	f0 e0       	ldi	r31, 0x00	; 0
  66:	80 81       	ld	r24, Z
  68:	88 2f       	mov	r24, r24
  6a:	90 e0       	ldi	r25, 0x00	; 0
  6c:	9a 83       	std	Y+2, r25	; 0x02
  6e:	89 83       	std	Y+1, r24	; 0x01
  70:	e5 e2       	ldi	r30, 0x25	; 37
  72:	f0 e0       	ldi	r31, 0x00	; 0
  74:	80 81       	ld	r24, Z
  76:	88 2f       	mov	r24, r24
  78:	90 e0       	ldi	r25, 0x00	; 0
  7a:	98 2f       	mov	r25, r24
  7c:	88 27       	eor	r24, r24
  7e:	9c 01       	movw	r18, r24
  80:	89 81       	ldd	r24, Y+1	; 0x01
  82:	9a 81       	ldd	r25, Y+2	; 0x02
  84:	82 2b       	or	r24, r18
  86:	93 2b       	or	r25, r19
  88:	9a 83       	std	Y+2, r25	; 0x02
  8a:	89 83       	std	Y+1, r24	; 0x01
  8c:	89 81       	ldd	r24, Y+1	; 0x01
  8e:	9a 81       	ldd	r25, Y+2	; 0x02
  90:	0f 90       	pop	r0
  92:	0f 90       	pop	r0
  94:	0f 90       	pop	r0
  96:	cf 91       	pop	r28
  98:	df 91       	pop	r29
  9a:	08 95       	ret

Disassembly of section .text.ADC_voidSelectChannel:

00000000 <ADC_voidSelectChannel>:

static u16 ADC_value;


u16 ADC_u16GetCurrentValue(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	0f 92       	push	r0
   6:	cd b7       	in	r28, 0x3d	; 61
	return ADC_value;
   8:	de b7       	in	r29, 0x3e	; 62
   a:	89 83       	std	Y+1, r24	; 0x01
   c:	a6 e2       	ldi	r26, 0x26	; 38
   e:	b0 e0       	ldi	r27, 0x00	; 0


}
  10:	e6 e2       	ldi	r30, 0x26	; 38
  12:	f0 e0       	ldi	r31, 0x00	; 0
  14:	80 81       	ld	r24, Z
  16:	80 64       	ori	r24, 0x40	; 64
  18:	8c 93       	st	X, r24
  1a:	0f 90       	pop	r0
  1c:	cf 91       	pop	r28
  1e:	df 91       	pop	r29
  20:	08 95       	ret

Disassembly of section .text.ADC_voidStartConversion:

00000000 <ADC_voidStartConversion>:

static u16 ADC_value;


u16 ADC_u16GetCurrentValue(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
	return ADC_value;
   8:	e6 e2       	ldi	r30, 0x26	; 38
   a:	f0 e0       	ldi	r31, 0x00	; 0
   c:	80 81       	ld	r24, Z
   e:	82 95       	swap	r24


}
  10:	86 95       	lsr	r24
  12:	86 95       	lsr	r24
  14:	83 70       	andi	r24, 0x03	; 3
  16:	88 2f       	mov	r24, r24
  18:	90 e0       	ldi	r25, 0x00	; 0
  1a:	81 70       	andi	r24, 0x01	; 1
  1c:	90 70       	andi	r25, 0x00	; 0
  1e:	00 97       	sbiw	r24, 0x00	; 0
  20:	01 f4       	brne	.+0      	; 0x22 <ADC_voidStartConversion+0x22>
  22:	a6 e2       	ldi	r26, 0x26	; 38
  24:	b0 e0       	ldi	r27, 0x00	; 0
  26:	e6 e2       	ldi	r30, 0x26	; 38
  28:	f0 e0       	ldi	r31, 0x00	; 0
  2a:	80 81       	ld	r24, Z
  2c:	80 61       	ori	r24, 0x10	; 16
  2e:	8c 93       	st	X, r24
  30:	cf 91       	pop	r28
  32:	df 91       	pop	r29
  34:	08 95       	ret

Disassembly of section .text.__vector_16:

00000000 <__vector_16>:

static u16 ADC_value;


u16 ADC_u16GetCurrentValue(void)
{
   0:	1f 92       	push	r1
   2:	0f 92       	push	r0
   4:	0f b6       	in	r0, 0x3f	; 63
   6:	0f 92       	push	r0
	return ADC_value;
   8:	11 24       	eor	r1, r1
   a:	2f 93       	push	r18
   c:	3f 93       	push	r19
   e:	8f 93       	push	r24


}
  10:	9f 93       	push	r25
  12:	ef 93       	push	r30
  14:	ff 93       	push	r31
  16:	df 93       	push	r29
  18:	cf 93       	push	r28
  1a:	cd b7       	in	r28, 0x3d	; 61
  1c:	de b7       	in	r29, 0x3e	; 62
  1e:	10 92 00 00 	sts	0x0000, r1
  22:	10 92 00 00 	sts	0x0000, r1
  26:	e4 e2       	ldi	r30, 0x24	; 36
  28:	f0 e0       	ldi	r31, 0x00	; 0
  2a:	80 81       	ld	r24, Z
  2c:	28 2f       	mov	r18, r24
  2e:	30 e0       	ldi	r19, 0x00	; 0
  30:	80 91 00 00 	lds	r24, 0x0000
  34:	90 91 00 00 	lds	r25, 0x0000
  38:	82 2b       	or	r24, r18
  3a:	93 2b       	or	r25, r19
  3c:	90 93 00 00 	sts	0x0000, r25
  40:	80 93 00 00 	sts	0x0000, r24
  44:	e5 e2       	ldi	r30, 0x25	; 37
  46:	f0 e0       	ldi	r31, 0x00	; 0
  48:	80 81       	ld	r24, Z
  4a:	88 2f       	mov	r24, r24
  4c:	90 e0       	ldi	r25, 0x00	; 0
  4e:	98 2f       	mov	r25, r24
  50:	88 27       	eor	r24, r24
  52:	9c 01       	movw	r18, r24
  54:	80 91 00 00 	lds	r24, 0x0000
  58:	90 91 00 00 	lds	r25, 0x0000
  5c:	82 2b       	or	r24, r18
  5e:	93 2b       	or	r25, r19
  60:	90 93 00 00 	sts	0x0000, r25
  64:	80 93 00 00 	sts	0x0000, r24
  68:	cf 91       	pop	r28
  6a:	df 91       	pop	r29
  6c:	ff 91       	pop	r31
  6e:	ef 91       	pop	r30
  70:	9f 91       	pop	r25
  72:	8f 91       	pop	r24
  74:	3f 91       	pop	r19
  76:	2f 91       	pop	r18
  78:	0f 90       	pop	r0
  7a:	0f be       	out	0x3f, r0	; 63
  7c:	0f 90       	pop	r0
  7e:	1f 90       	pop	r1
  80:	18 95       	reti

DIO_prog.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000600  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      000008f9  00000000  00000000  00000634  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.DIO_voidSetPinDir 000001c6  00000000  00000000  00000f2d  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  6 .text.DIO_voidSetPinValue 000001c6  00000000  00000000  000010f3  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  7 .text.DIO_voidTogglePinValue 000000fa  00000000  00000000  000012b9  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  8 .text.DIO_u8GetPinValue 00000104  00000000  00000000  000013b3  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.DIO_voidSetPinDir:

00000000 <DIO_voidSetPinDir>:




void DIO_voidSetPinDir(u8 Port,u8 Pin,u8 Dir)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <DIO_voidSetPinDir+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <DIO_voidSetPinDir+0x8>
   8:	0f 92       	push	r0
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
   e:	89 83       	std	Y+1, r24	; 0x01
  10:	6a 83       	std	Y+2, r22	; 0x02
  12:	4b 83       	std	Y+3, r20	; 0x03

switch(Port)
  14:	89 81       	ldd	r24, Y+1	; 0x01
  16:	28 2f       	mov	r18, r24
  18:	30 e0       	ldi	r19, 0x00	; 0
  1a:	3d 83       	std	Y+5, r19	; 0x05
  1c:	2c 83       	std	Y+4, r18	; 0x04
  1e:	8c 81       	ldd	r24, Y+4	; 0x04
  20:	9d 81       	ldd	r25, Y+5	; 0x05
  22:	81 30       	cpi	r24, 0x01	; 1
  24:	91 05       	cpc	r25, r1
  26:	01 f4       	brne	.+0      	; 0x28 <DIO_voidSetPinDir+0x28>
  28:	00 c0       	rjmp	.+0      	; 0x2a <DIO_voidSetPinDir+0x2a>
  2a:	2c 81       	ldd	r18, Y+4	; 0x04
  2c:	3d 81       	ldd	r19, Y+5	; 0x05
  2e:	22 30       	cpi	r18, 0x02	; 2
  30:	31 05       	cpc	r19, r1
  32:	04 f4       	brge	.+0      	; 0x34 <DIO_voidSetPinDir+0x34>
  34:	8c 81       	ldd	r24, Y+4	; 0x04
  36:	9d 81       	ldd	r25, Y+5	; 0x05
  38:	00 97       	sbiw	r24, 0x00	; 0
  3a:	01 f0       	breq	.+0      	; 0x3c <DIO_voidSetPinDir+0x3c>
  3c:	00 c0       	rjmp	.+0      	; 0x3e <DIO_voidSetPinDir+0x3e>
  3e:	2c 81       	ldd	r18, Y+4	; 0x04
  40:	3d 81       	ldd	r19, Y+5	; 0x05
  42:	22 30       	cpi	r18, 0x02	; 2
  44:	31 05       	cpc	r19, r1
  46:	01 f4       	brne	.+0      	; 0x48 <DIO_voidSetPinDir+0x48>
  48:	00 c0       	rjmp	.+0      	; 0x4a <DIO_voidSetPinDir+0x4a>
  4a:	8c 81       	ldd	r24, Y+4	; 0x04
  4c:	9d 81       	ldd	r25, Y+5	; 0x05
  4e:	83 30       	cpi	r24, 0x03	; 3
  50:	91 05       	cpc	r25, r1
  52:	01 f4       	brne	.+0      	; 0x54 <DIO_voidSetPinDir+0x54>
  54:	00 c0       	rjmp	.+0      	; 0x56 <DIO_voidSetPinDir+0x56>
  56:	00 c0       	rjmp	.+0      	; 0x58 <DIO_voidSetPinDir+0x58>
{
	case 0:
		if(Dir==0)
  58:	8b 81       	ldd	r24, Y+3	; 0x03
  5a:	88 23       	and	r24, r24
  5c:	01 f4       	brne	.+0      	; 0x5e <DIO_voidSetPinDir+0x5e>
		{
			CLEAR_BIT(DDRA,Pin);
  5e:	aa e3       	ldi	r26, 0x3A	; 58
  60:	b0 e0       	ldi	r27, 0x00	; 0
  62:	ea e3       	ldi	r30, 0x3A	; 58
  64:	f0 e0       	ldi	r31, 0x00	; 0
  66:	80 81       	ld	r24, Z
  68:	48 2f       	mov	r20, r24
  6a:	8a 81       	ldd	r24, Y+2	; 0x02
  6c:	28 2f       	mov	r18, r24
  6e:	30 e0       	ldi	r19, 0x00	; 0
  70:	81 e0       	ldi	r24, 0x01	; 1
  72:	90 e0       	ldi	r25, 0x00	; 0
  74:	02 2e       	mov	r0, r18
  76:	00 c0       	rjmp	.+0      	; 0x78 <DIO_voidSetPinDir+0x78>
  78:	88 0f       	add	r24, r24
  7a:	99 1f       	adc	r25, r25
  7c:	0a 94       	dec	r0
  7e:	02 f4       	brpl	.+0      	; 0x80 <DIO_voidSetPinDir+0x80>
  80:	80 95       	com	r24
  82:	84 23       	and	r24, r20
  84:	8c 93       	st	X, r24
  86:	00 c0       	rjmp	.+0      	; 0x88 <DIO_voidSetPinDir+0x88>

		}
		else
		{
			SET_BIT(DDRA,Pin);
  88:	aa e3       	ldi	r26, 0x3A	; 58
  8a:	b0 e0       	ldi	r27, 0x00	; 0
  8c:	ea e3       	ldi	r30, 0x3A	; 58
  8e:	f0 e0       	ldi	r31, 0x00	; 0
  90:	80 81       	ld	r24, Z
  92:	48 2f       	mov	r20, r24
  94:	8a 81       	ldd	r24, Y+2	; 0x02
  96:	28 2f       	mov	r18, r24
  98:	30 e0       	ldi	r19, 0x00	; 0
  9a:	81 e0       	ldi	r24, 0x01	; 1
  9c:	90 e0       	ldi	r25, 0x00	; 0
  9e:	02 2e       	mov	r0, r18
  a0:	00 c0       	rjmp	.+0      	; 0xa2 <DIO_voidSetPinDir+0xa2>
  a2:	88 0f       	add	r24, r24
  a4:	99 1f       	adc	r25, r25
  a6:	0a 94       	dec	r0
  a8:	02 f4       	brpl	.+0      	; 0xaa <DIO_voidSetPinDir+0xaa>
  aa:	84 2b       	or	r24, r20
  ac:	8c 93       	st	X, r24
  ae:	00 c0       	rjmp	.+0      	; 0xb0 <DIO_voidSetPinDir+0xb0>



		break;
	case 1:
		if(Dir==0)
  b0:	8b 81       	ldd	r24, Y+3	; 0x03
  b2:	88 23       	and	r24, r24
  b4:	01 f4       	brne	.+0      	; 0xb6 <DIO_voidSetPinDir+0xb6>
				{
					CLEAR_BIT(DDRB,Pin);
  b6:	a7 e3       	ldi	r26, 0x37	; 55
  b8:	b0 e0       	ldi	r27, 0x00	; 0
  ba:	e7 e3       	ldi	r30, 0x37	; 55
  bc:	f0 e0       	ldi	r31, 0x00	; 0
  be:	80 81       	ld	r24, Z
  c0:	48 2f       	mov	r20, r24
  c2:	8a 81       	ldd	r24, Y+2	; 0x02
  c4:	28 2f       	mov	r18, r24
  c6:	30 e0       	ldi	r19, 0x00	; 0
  c8:	81 e0       	ldi	r24, 0x01	; 1
  ca:	90 e0       	ldi	r25, 0x00	; 0
  cc:	02 2e       	mov	r0, r18
  ce:	00 c0       	rjmp	.+0      	; 0xd0 <DIO_voidSetPinDir+0xd0>
  d0:	88 0f       	add	r24, r24
  d2:	99 1f       	adc	r25, r25
  d4:	0a 94       	dec	r0
  d6:	02 f4       	brpl	.+0      	; 0xd8 <DIO_voidSetPinDir+0xd8>
  d8:	80 95       	com	r24
  da:	84 23       	and	r24, r20
  dc:	8c 93       	st	X, r24
  de:	00 c0       	rjmp	.+0      	; 0xe0 <DIO_voidSetPinDir+0xe0>

				}
				else
				{
					SET_BIT(DDRB,Pin);
  e0:	a7 e3       	ldi	r26, 0x37	; 55
  e2:	b0 e0       	ldi	r27, 0x00	; 0
  e4:	e7 e3       	ldi	r30, 0x37	; 55
  e6:	f0 e0       	ldi	r31, 0x00	; 0
  e8:	80 81       	ld	r24, Z
  ea:	48 2f       	mov	r20, r24
  ec:	8a 81       	ldd	r24, Y+2	; 0x02
  ee:	28 2f       	mov	r18, r24
  f0:	30 e0       	ldi	r19, 0x00	; 0
  f2:	81 e0       	ldi	r24, 0x01	; 1
  f4:	90 e0       	ldi	r25, 0x00	; 0
  f6:	02 2e       	mov	r0, r18
  f8:	00 c0       	rjmp	.+0      	; 0xfa <DIO_voidSetPinDir+0xfa>
  fa:	88 0f       	add	r24, r24
  fc:	99 1f       	adc	r25, r25
  fe:	0a 94       	dec	r0
 100:	02 f4       	brpl	.+0      	; 0x102 <DIO_voidSetPinDir+0x102>
 102:	84 2b       	or	r24, r20
 104:	8c 93       	st	X, r24
 106:	00 c0       	rjmp	.+0      	; 0x108 <DIO_voidSetPinDir+0x108>
				}


		break;
	case 2:
		if(Dir==0)
 108:	8b 81       	ldd	r24, Y+3	; 0x03
 10a:	88 23       	and	r24, r24
 10c:	01 f4       	brne	.+0      	; 0x10e <DIO_voidSetPinDir+0x10e>
				{
					CLEAR_BIT(DDRC,Pin);
 10e:	a4 e3       	ldi	r26, 0x34	; 52
 110:	b0 e0       	ldi	r27, 0x00	; 0
 112:	e4 e3       	ldi	r30, 0x34	; 52
 114:	f0 e0       	ldi	r31, 0x00	; 0
 116:	80 81       	ld	r24, Z
 118:	48 2f       	mov	r20, r24
 11a:	8a 81       	ldd	r24, Y+2	; 0x02
 11c:	28 2f       	mov	r18, r24
 11e:	30 e0       	ldi	r19, 0x00	; 0
 120:	81 e0       	ldi	r24, 0x01	; 1
 122:	90 e0       	ldi	r25, 0x00	; 0
 124:	02 2e       	mov	r0, r18
 126:	00 c0       	rjmp	.+0      	; 0x128 <DIO_voidSetPinDir+0x128>
 128:	88 0f       	add	r24, r24
 12a:	99 1f       	adc	r25, r25
 12c:	0a 94       	dec	r0
 12e:	02 f4       	brpl	.+0      	; 0x130 <DIO_voidSetPinDir+0x130>
 130:	80 95       	com	r24
 132:	84 23       	and	r24, r20
 134:	8c 93       	st	X, r24
 136:	00 c0       	rjmp	.+0      	; 0x138 <DIO_voidSetPinDir+0x138>

				}
				else
				{
					SET_BIT(DDRC,Pin);
 138:	a4 e3       	ldi	r26, 0x34	; 52
 13a:	b0 e0       	ldi	r27, 0x00	; 0
 13c:	e4 e3       	ldi	r30, 0x34	; 52
 13e:	f0 e0       	ldi	r31, 0x00	; 0
 140:	80 81       	ld	r24, Z
 142:	48 2f       	mov	r20, r24
 144:	8a 81       	ldd	r24, Y+2	; 0x02
 146:	28 2f       	mov	r18, r24
 148:	30 e0       	ldi	r19, 0x00	; 0
 14a:	81 e0       	ldi	r24, 0x01	; 1
 14c:	90 e0       	ldi	r25, 0x00	; 0
 14e:	02 2e       	mov	r0, r18
 150:	00 c0       	rjmp	.+0      	; 0x152 <DIO_voidSetPinDir+0x152>
 152:	88 0f       	add	r24, r24
 154:	99 1f       	adc	r25, r25
 156:	0a 94       	dec	r0
 158:	02 f4       	brpl	.+0      	; 0x15a <DIO_voidSetPinDir+0x15a>
 15a:	84 2b       	or	r24, r20
 15c:	8c 93       	st	X, r24
 15e:	00 c0       	rjmp	.+0      	; 0x160 <DIO_voidSetPinDir+0x160>


		break;

	case 3:
		if(Dir==0)
 160:	8b 81       	ldd	r24, Y+3	; 0x03
 162:	88 23       	and	r24, r24
 164:	01 f4       	brne	.+0      	; 0x166 <DIO_voidSetPinDir+0x166>
				{
					CLEAR_BIT(DDRD,Pin);
 166:	a1 e3       	ldi	r26, 0x31	; 49
 168:	b0 e0       	ldi	r27, 0x00	; 0
 16a:	e1 e3       	ldi	r30, 0x31	; 49
 16c:	f0 e0       	ldi	r31, 0x00	; 0
 16e:	80 81       	ld	r24, Z
 170:	48 2f       	mov	r20, r24
 172:	8a 81       	ldd	r24, Y+2	; 0x02
 174:	28 2f       	mov	r18, r24
 176:	30 e0       	ldi	r19, 0x00	; 0
 178:	81 e0       	ldi	r24, 0x01	; 1
 17a:	90 e0       	ldi	r25, 0x00	; 0
 17c:	02 2e       	mov	r0, r18
 17e:	00 c0       	rjmp	.+0      	; 0x180 <DIO_voidSetPinDir+0x180>
 180:	88 0f       	add	r24, r24
 182:	99 1f       	adc	r25, r25
 184:	0a 94       	dec	r0
 186:	02 f4       	brpl	.+0      	; 0x188 <DIO_voidSetPinDir+0x188>
 188:	80 95       	com	r24
 18a:	84 23       	and	r24, r20
 18c:	8c 93       	st	X, r24
 18e:	00 c0       	rjmp	.+0      	; 0x190 <DIO_voidSetPinDir+0x190>

				}
				else
				{
					SET_BIT(DDRD,Pin);
 190:	a1 e3       	ldi	r26, 0x31	; 49
 192:	b0 e0       	ldi	r27, 0x00	; 0
 194:	e1 e3       	ldi	r30, 0x31	; 49
 196:	f0 e0       	ldi	r31, 0x00	; 0
 198:	80 81       	ld	r24, Z
 19a:	48 2f       	mov	r20, r24
 19c:	8a 81       	ldd	r24, Y+2	; 0x02
 19e:	28 2f       	mov	r18, r24
 1a0:	30 e0       	ldi	r19, 0x00	; 0
 1a2:	81 e0       	ldi	r24, 0x01	; 1
 1a4:	90 e0       	ldi	r25, 0x00	; 0
 1a6:	02 2e       	mov	r0, r18
 1a8:	00 c0       	rjmp	.+0      	; 0x1aa <DIO_voidSetPinDir+0x1aa>
 1aa:	88 0f       	add	r24, r24
 1ac:	99 1f       	adc	r25, r25
 1ae:	0a 94       	dec	r0
 1b0:	02 f4       	brpl	.+0      	; 0x1b2 <DIO_voidSetPinDir+0x1b2>
 1b2:	84 2b       	or	r24, r20
 1b4:	8c 93       	st	X, r24

		break;
}


}
 1b6:	0f 90       	pop	r0
 1b8:	0f 90       	pop	r0
 1ba:	0f 90       	pop	r0
 1bc:	0f 90       	pop	r0
 1be:	0f 90       	pop	r0
 1c0:	cf 91       	pop	r28
 1c2:	df 91       	pop	r29
 1c4:	08 95       	ret

Disassembly of section .text.DIO_voidSetPinValue:

00000000 <DIO_voidSetPinValue>:




void DIO_voidSetPinDir(u8 Port,u8 Pin,u8 Dir)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <DIO_voidSetPinValue+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <DIO_voidSetPinValue+0x8>
   8:	0f 92       	push	r0
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
   e:	89 83       	std	Y+1, r24	; 0x01
  10:	6a 83       	std	Y+2, r22	; 0x02
  12:	4b 83       	std	Y+3, r20	; 0x03

switch(Port)
  14:	89 81       	ldd	r24, Y+1	; 0x01
  16:	28 2f       	mov	r18, r24
  18:	30 e0       	ldi	r19, 0x00	; 0
  1a:	3d 83       	std	Y+5, r19	; 0x05
  1c:	2c 83       	std	Y+4, r18	; 0x04
  1e:	8c 81       	ldd	r24, Y+4	; 0x04
  20:	9d 81       	ldd	r25, Y+5	; 0x05
  22:	81 30       	cpi	r24, 0x01	; 1
  24:	91 05       	cpc	r25, r1
  26:	01 f4       	brne	.+0      	; 0x28 <DIO_voidSetPinValue+0x28>
  28:	00 c0       	rjmp	.+0      	; 0x2a <DIO_voidSetPinValue+0x2a>
  2a:	2c 81       	ldd	r18, Y+4	; 0x04
  2c:	3d 81       	ldd	r19, Y+5	; 0x05
  2e:	22 30       	cpi	r18, 0x02	; 2
  30:	31 05       	cpc	r19, r1
  32:	04 f4       	brge	.+0      	; 0x34 <DIO_voidSetPinValue+0x34>
  34:	8c 81       	ldd	r24, Y+4	; 0x04
  36:	9d 81       	ldd	r25, Y+5	; 0x05
  38:	00 97       	sbiw	r24, 0x00	; 0
  3a:	01 f0       	breq	.+0      	; 0x3c <DIO_voidSetPinValue+0x3c>
  3c:	00 c0       	rjmp	.+0      	; 0x3e <DIO_voidSetPinValue+0x3e>
  3e:	2c 81       	ldd	r18, Y+4	; 0x04
  40:	3d 81       	ldd	r19, Y+5	; 0x05
  42:	22 30       	cpi	r18, 0x02	; 2
  44:	31 05       	cpc	r19, r1
  46:	01 f4       	brne	.+0      	; 0x48 <DIO_voidSetPinValue+0x48>
  48:	00 c0       	rjmp	.+0      	; 0x4a <DIO_voidSetPinValue+0x4a>
  4a:	8c 81       	ldd	r24, Y+4	; 0x04
  4c:	9d 81       	ldd	r25, Y+5	; 0x05
  4e:	83 30       	cpi	r24, 0x03	; 3
  50:	91 05       	cpc	r25, r1
  52:	01 f4       	brne	.+0      	; 0x54 <DIO_voidSetPinValue+0x54>
  54:	00 c0       	rjmp	.+0      	; 0x56 <DIO_voidSetPinValue+0x56>
  56:	00 c0       	rjmp	.+0      	; 0x58 <DIO_voidSetPinValue+0x58>
{
	case 0:
		if(Dir==0)
  58:	8b 81       	ldd	r24, Y+3	; 0x03
  5a:	88 23       	and	r24, r24
  5c:	01 f4       	brne	.+0      	; 0x5e <DIO_voidSetPinValue+0x5e>
		{
			CLEAR_BIT(DDRA,Pin);
  5e:	ab e3       	ldi	r26, 0x3B	; 59
  60:	b0 e0       	ldi	r27, 0x00	; 0
  62:	eb e3       	ldi	r30, 0x3B	; 59
  64:	f0 e0       	ldi	r31, 0x00	; 0
  66:	80 81       	ld	r24, Z
  68:	48 2f       	mov	r20, r24
  6a:	8a 81       	ldd	r24, Y+2	; 0x02
  6c:	28 2f       	mov	r18, r24
  6e:	30 e0       	ldi	r19, 0x00	; 0
  70:	81 e0       	ldi	r24, 0x01	; 1
  72:	90 e0       	ldi	r25, 0x00	; 0
  74:	02 2e       	mov	r0, r18
  76:	00 c0       	rjmp	.+0      	; 0x78 <DIO_voidSetPinValue+0x78>
  78:	88 0f       	add	r24, r24
  7a:	99 1f       	adc	r25, r25
  7c:	0a 94       	dec	r0
  7e:	02 f4       	brpl	.+0      	; 0x80 <DIO_voidSetPinValue+0x80>
  80:	80 95       	com	r24
  82:	84 23       	and	r24, r20
  84:	8c 93       	st	X, r24
  86:	00 c0       	rjmp	.+0      	; 0x88 <DIO_voidSetPinValue+0x88>

		}
		else
		{
			SET_BIT(DDRA,Pin);
  88:	ab e3       	ldi	r26, 0x3B	; 59
  8a:	b0 e0       	ldi	r27, 0x00	; 0
  8c:	eb e3       	ldi	r30, 0x3B	; 59
  8e:	f0 e0       	ldi	r31, 0x00	; 0
  90:	80 81       	ld	r24, Z
  92:	48 2f       	mov	r20, r24
  94:	8a 81       	ldd	r24, Y+2	; 0x02
  96:	28 2f       	mov	r18, r24
  98:	30 e0       	ldi	r19, 0x00	; 0
  9a:	81 e0       	ldi	r24, 0x01	; 1
  9c:	90 e0       	ldi	r25, 0x00	; 0
  9e:	02 2e       	mov	r0, r18
  a0:	00 c0       	rjmp	.+0      	; 0xa2 <DIO_voidSetPinValue+0xa2>
  a2:	88 0f       	add	r24, r24
  a4:	99 1f       	adc	r25, r25
  a6:	0a 94       	dec	r0
  a8:	02 f4       	brpl	.+0      	; 0xaa <DIO_voidSetPinValue+0xaa>
  aa:	84 2b       	or	r24, r20
  ac:	8c 93       	st	X, r24
  ae:	00 c0       	rjmp	.+0      	; 0xb0 <DIO_voidSetPinValue+0xb0>



		break;
	case 1:
		if(Dir==0)
  b0:	8b 81       	ldd	r24, Y+3	; 0x03
  b2:	88 23       	and	r24, r24
  b4:	01 f4       	brne	.+0      	; 0xb6 <DIO_voidSetPinValue+0xb6>
				{
					CLEAR_BIT(DDRB,Pin);
  b6:	a8 e3       	ldi	r26, 0x38	; 56
  b8:	b0 e0       	ldi	r27, 0x00	; 0
  ba:	e8 e3       	ldi	r30, 0x38	; 56
  bc:	f0 e0       	ldi	r31, 0x00	; 0
  be:	80 81       	ld	r24, Z
  c0:	48 2f       	mov	r20, r24
  c2:	8a 81       	ldd	r24, Y+2	; 0x02
  c4:	28 2f       	mov	r18, r24
  c6:	30 e0       	ldi	r19, 0x00	; 0
  c8:	81 e0       	ldi	r24, 0x01	; 1
  ca:	90 e0       	ldi	r25, 0x00	; 0
  cc:	02 2e       	mov	r0, r18
  ce:	00 c0       	rjmp	.+0      	; 0xd0 <DIO_voidSetPinValue+0xd0>
  d0:	88 0f       	add	r24, r24
  d2:	99 1f       	adc	r25, r25
  d4:	0a 94       	dec	r0
  d6:	02 f4       	brpl	.+0      	; 0xd8 <DIO_voidSetPinValue+0xd8>
  d8:	80 95       	com	r24
  da:	84 23       	and	r24, r20
  dc:	8c 93       	st	X, r24
  de:	00 c0       	rjmp	.+0      	; 0xe0 <DIO_voidSetPinValue+0xe0>

				}
				else
				{
					SET_BIT(DDRB,Pin);
  e0:	a8 e3       	ldi	r26, 0x38	; 56
  e2:	b0 e0       	ldi	r27, 0x00	; 0
  e4:	e8 e3       	ldi	r30, 0x38	; 56
  e6:	f0 e0       	ldi	r31, 0x00	; 0
  e8:	80 81       	ld	r24, Z
  ea:	48 2f       	mov	r20, r24
  ec:	8a 81       	ldd	r24, Y+2	; 0x02
  ee:	28 2f       	mov	r18, r24
  f0:	30 e0       	ldi	r19, 0x00	; 0
  f2:	81 e0       	ldi	r24, 0x01	; 1
  f4:	90 e0       	ldi	r25, 0x00	; 0
  f6:	02 2e       	mov	r0, r18
  f8:	00 c0       	rjmp	.+0      	; 0xfa <DIO_voidSetPinValue+0xfa>
  fa:	88 0f       	add	r24, r24
  fc:	99 1f       	adc	r25, r25
  fe:	0a 94       	dec	r0
 100:	02 f4       	brpl	.+0      	; 0x102 <DIO_voidSetPinValue+0x102>
 102:	84 2b       	or	r24, r20
 104:	8c 93       	st	X, r24
 106:	00 c0       	rjmp	.+0      	; 0x108 <DIO_voidSetPinValue+0x108>
				}


		break;
	case 2:
		if(Dir==0)
 108:	8b 81       	ldd	r24, Y+3	; 0x03
 10a:	88 23       	and	r24, r24
 10c:	01 f4       	brne	.+0      	; 0x10e <DIO_voidSetPinValue+0x10e>
				{
					CLEAR_BIT(DDRC,Pin);
 10e:	a5 e3       	ldi	r26, 0x35	; 53
 110:	b0 e0       	ldi	r27, 0x00	; 0
 112:	e5 e3       	ldi	r30, 0x35	; 53
 114:	f0 e0       	ldi	r31, 0x00	; 0
 116:	80 81       	ld	r24, Z
 118:	48 2f       	mov	r20, r24
 11a:	8a 81       	ldd	r24, Y+2	; 0x02
 11c:	28 2f       	mov	r18, r24
 11e:	30 e0       	ldi	r19, 0x00	; 0
 120:	81 e0       	ldi	r24, 0x01	; 1
 122:	90 e0       	ldi	r25, 0x00	; 0
 124:	02 2e       	mov	r0, r18
 126:	00 c0       	rjmp	.+0      	; 0x128 <DIO_voidSetPinValue+0x128>
 128:	88 0f       	add	r24, r24
 12a:	99 1f       	adc	r25, r25
 12c:	0a 94       	dec	r0
 12e:	02 f4       	brpl	.+0      	; 0x130 <DIO_voidSetPinValue+0x130>
 130:	80 95       	com	r24
 132:	84 23       	and	r24, r20
 134:	8c 93       	st	X, r24
 136:	00 c0       	rjmp	.+0      	; 0x138 <DIO_voidSetPinValue+0x138>

				}
				else
				{
					SET_BIT(DDRC,Pin);
 138:	a5 e3       	ldi	r26, 0x35	; 53
 13a:	b0 e0       	ldi	r27, 0x00	; 0
 13c:	e5 e3       	ldi	r30, 0x35	; 53
 13e:	f0 e0       	ldi	r31, 0x00	; 0
 140:	80 81       	ld	r24, Z
 142:	48 2f       	mov	r20, r24
 144:	8a 81       	ldd	r24, Y+2	; 0x02
 146:	28 2f       	mov	r18, r24
 148:	30 e0       	ldi	r19, 0x00	; 0
 14a:	81 e0       	ldi	r24, 0x01	; 1
 14c:	90 e0       	ldi	r25, 0x00	; 0
 14e:	02 2e       	mov	r0, r18
 150:	00 c0       	rjmp	.+0      	; 0x152 <DIO_voidSetPinValue+0x152>
 152:	88 0f       	add	r24, r24
 154:	99 1f       	adc	r25, r25
 156:	0a 94       	dec	r0
 158:	02 f4       	brpl	.+0      	; 0x15a <DIO_voidSetPinValue+0x15a>
 15a:	84 2b       	or	r24, r20
 15c:	8c 93       	st	X, r24
 15e:	00 c0       	rjmp	.+0      	; 0x160 <DIO_voidSetPinValue+0x160>


		break;

	case 3:
		if(Dir==0)
 160:	8b 81       	ldd	r24, Y+3	; 0x03
 162:	88 23       	and	r24, r24
 164:	01 f4       	brne	.+0      	; 0x166 <DIO_voidSetPinValue+0x166>
				{
					CLEAR_BIT(DDRD,Pin);
 166:	a2 e3       	ldi	r26, 0x32	; 50
 168:	b0 e0       	ldi	r27, 0x00	; 0
 16a:	e2 e3       	ldi	r30, 0x32	; 50
 16c:	f0 e0       	ldi	r31, 0x00	; 0
 16e:	80 81       	ld	r24, Z
 170:	48 2f       	mov	r20, r24
 172:	8a 81       	ldd	r24, Y+2	; 0x02
 174:	28 2f       	mov	r18, r24
 176:	30 e0       	ldi	r19, 0x00	; 0
 178:	81 e0       	ldi	r24, 0x01	; 1
 17a:	90 e0       	ldi	r25, 0x00	; 0
 17c:	02 2e       	mov	r0, r18
 17e:	00 c0       	rjmp	.+0      	; 0x180 <DIO_voidSetPinValue+0x180>
 180:	88 0f       	add	r24, r24
 182:	99 1f       	adc	r25, r25
 184:	0a 94       	dec	r0
 186:	02 f4       	brpl	.+0      	; 0x188 <DIO_voidSetPinValue+0x188>
 188:	80 95       	com	r24
 18a:	84 23       	and	r24, r20
 18c:	8c 93       	st	X, r24
 18e:	00 c0       	rjmp	.+0      	; 0x190 <DIO_voidSetPinValue+0x190>

				}
				else
				{
					SET_BIT(DDRD,Pin);
 190:	a2 e3       	ldi	r26, 0x32	; 50
 192:	b0 e0       	ldi	r27, 0x00	; 0
 194:	e2 e3       	ldi	r30, 0x32	; 50
 196:	f0 e0       	ldi	r31, 0x00	; 0
 198:	80 81       	ld	r24, Z
 19a:	48 2f       	mov	r20, r24
 19c:	8a 81       	ldd	r24, Y+2	; 0x02
 19e:	28 2f       	mov	r18, r24
 1a0:	30 e0       	ldi	r19, 0x00	; 0
 1a2:	81 e0       	ldi	r24, 0x01	; 1
 1a4:	90 e0       	ldi	r25, 0x00	; 0
 1a6:	02 2e       	mov	r0, r18
 1a8:	00 c0       	rjmp	.+0      	; 0x1aa <DIO_voidSetPinValue+0x1aa>
 1aa:	88 0f       	add	r24, r24
 1ac:	99 1f       	adc	r25, r25
 1ae:	0a 94       	dec	r0
 1b0:	02 f4       	brpl	.+0      	; 0x1b2 <DIO_voidSetPinValue+0x1b2>
 1b2:	84 2b       	or	r24, r20
 1b4:	8c 93       	st	X, r24

		break;
}


}
 1b6:	0f 90       	pop	r0
 1b8:	0f 90       	pop	r0
 1ba:	0f 90       	pop	r0
 1bc:	0f 90       	pop	r0
 1be:	0f 90       	pop	r0
 1c0:	cf 91       	pop	r28
 1c2:	df 91       	pop	r29
 1c4:	08 95       	ret

Disassembly of section .text.DIO_voidTogglePinValue:

00000000 <DIO_voidTogglePinValue>:




void DIO_voidSetPinDir(u8 Port,u8 Pin,u8 Dir)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <DIO_voidTogglePinValue+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <DIO_voidTogglePinValue+0x8>
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	89 83       	std	Y+1, r24	; 0x01
   e:	6a 83       	std	Y+2, r22	; 0x02
  10:	89 81       	ldd	r24, Y+1	; 0x01
  12:	28 2f       	mov	r18, r24

switch(Port)
  14:	30 e0       	ldi	r19, 0x00	; 0
  16:	3c 83       	std	Y+4, r19	; 0x04
  18:	2b 83       	std	Y+3, r18	; 0x03
  1a:	8b 81       	ldd	r24, Y+3	; 0x03
  1c:	9c 81       	ldd	r25, Y+4	; 0x04
  1e:	81 30       	cpi	r24, 0x01	; 1
  20:	91 05       	cpc	r25, r1
  22:	01 f0       	breq	.+0      	; 0x24 <DIO_voidTogglePinValue+0x24>
  24:	2b 81       	ldd	r18, Y+3	; 0x03
  26:	3c 81       	ldd	r19, Y+4	; 0x04
  28:	22 30       	cpi	r18, 0x02	; 2
  2a:	31 05       	cpc	r19, r1
  2c:	04 f4       	brge	.+0      	; 0x2e <DIO_voidTogglePinValue+0x2e>
  2e:	8b 81       	ldd	r24, Y+3	; 0x03
  30:	9c 81       	ldd	r25, Y+4	; 0x04
  32:	00 97       	sbiw	r24, 0x00	; 0
  34:	01 f0       	breq	.+0      	; 0x36 <DIO_voidTogglePinValue+0x36>
  36:	00 c0       	rjmp	.+0      	; 0x38 <DIO_voidTogglePinValue+0x38>
  38:	2b 81       	ldd	r18, Y+3	; 0x03
  3a:	3c 81       	ldd	r19, Y+4	; 0x04
  3c:	22 30       	cpi	r18, 0x02	; 2
  3e:	31 05       	cpc	r19, r1
  40:	01 f0       	breq	.+0      	; 0x42 <DIO_voidTogglePinValue+0x42>
  42:	8b 81       	ldd	r24, Y+3	; 0x03
  44:	9c 81       	ldd	r25, Y+4	; 0x04
  46:	83 30       	cpi	r24, 0x03	; 3
  48:	91 05       	cpc	r25, r1
  4a:	01 f0       	breq	.+0      	; 0x4c <DIO_voidTogglePinValue+0x4c>
  4c:	00 c0       	rjmp	.+0      	; 0x4e <DIO_voidTogglePinValue+0x4e>
  4e:	ab e3       	ldi	r26, 0x3B	; 59
  50:	b0 e0       	ldi	r27, 0x00	; 0
  52:	eb e3       	ldi	r30, 0x3B	; 59
  54:	f0 e0       	ldi	r31, 0x00	; 0
  56:	80 81       	ld	r24, Z
{
	case 0:
		if(Dir==0)
  58:	48 2f       	mov	r20, r24
  5a:	8a 81       	ldd	r24, Y+2	; 0x02
  5c:	28 2f       	mov	r18, r24
		{
			CLEAR_BIT(DDRA,Pin);
  5e:	30 e0       	ldi	r19, 0x00	; 0
  60:	81 e0       	ldi	r24, 0x01	; 1
  62:	90 e0       	ldi	r25, 0x00	; 0
  64:	02 2e       	mov	r0, r18
  66:	00 c0       	rjmp	.+0      	; 0x68 <DIO_voidTogglePinValue+0x68>
  68:	88 0f       	add	r24, r24
  6a:	99 1f       	adc	r25, r25
  6c:	0a 94       	dec	r0
  6e:	02 f4       	brpl	.+0      	; 0x70 <DIO_voidTogglePinValue+0x70>
  70:	84 27       	eor	r24, r20
  72:	8c 93       	st	X, r24
  74:	00 c0       	rjmp	.+0      	; 0x76 <DIO_voidTogglePinValue+0x76>
  76:	a8 e3       	ldi	r26, 0x38	; 56
  78:	b0 e0       	ldi	r27, 0x00	; 0
  7a:	e8 e3       	ldi	r30, 0x38	; 56
  7c:	f0 e0       	ldi	r31, 0x00	; 0
  7e:	80 81       	ld	r24, Z
  80:	48 2f       	mov	r20, r24
  82:	8a 81       	ldd	r24, Y+2	; 0x02
  84:	28 2f       	mov	r18, r24
  86:	30 e0       	ldi	r19, 0x00	; 0

		}
		else
		{
			SET_BIT(DDRA,Pin);
  88:	81 e0       	ldi	r24, 0x01	; 1
  8a:	90 e0       	ldi	r25, 0x00	; 0
  8c:	02 2e       	mov	r0, r18
  8e:	00 c0       	rjmp	.+0      	; 0x90 <DIO_voidTogglePinValue+0x90>
  90:	88 0f       	add	r24, r24
  92:	99 1f       	adc	r25, r25
  94:	0a 94       	dec	r0
  96:	02 f4       	brpl	.+0      	; 0x98 <DIO_voidTogglePinValue+0x98>
  98:	84 27       	eor	r24, r20
  9a:	8c 93       	st	X, r24
  9c:	00 c0       	rjmp	.+0      	; 0x9e <DIO_voidTogglePinValue+0x9e>
  9e:	a5 e3       	ldi	r26, 0x35	; 53
  a0:	b0 e0       	ldi	r27, 0x00	; 0
  a2:	e5 e3       	ldi	r30, 0x35	; 53
  a4:	f0 e0       	ldi	r31, 0x00	; 0
  a6:	80 81       	ld	r24, Z
  a8:	48 2f       	mov	r20, r24
  aa:	8a 81       	ldd	r24, Y+2	; 0x02
  ac:	28 2f       	mov	r18, r24
  ae:	30 e0       	ldi	r19, 0x00	; 0



		break;
	case 1:
		if(Dir==0)
  b0:	81 e0       	ldi	r24, 0x01	; 1
  b2:	90 e0       	ldi	r25, 0x00	; 0
  b4:	02 2e       	mov	r0, r18
				{
					CLEAR_BIT(DDRB,Pin);
  b6:	00 c0       	rjmp	.+0      	; 0xb8 <DIO_voidTogglePinValue+0xb8>
  b8:	88 0f       	add	r24, r24
  ba:	99 1f       	adc	r25, r25
  bc:	0a 94       	dec	r0
  be:	02 f4       	brpl	.+0      	; 0xc0 <DIO_voidTogglePinValue+0xc0>
  c0:	84 27       	eor	r24, r20
  c2:	8c 93       	st	X, r24
  c4:	00 c0       	rjmp	.+0      	; 0xc6 <DIO_voidTogglePinValue+0xc6>
  c6:	a2 e3       	ldi	r26, 0x32	; 50
  c8:	b0 e0       	ldi	r27, 0x00	; 0
  ca:	e2 e3       	ldi	r30, 0x32	; 50
  cc:	f0 e0       	ldi	r31, 0x00	; 0
  ce:	80 81       	ld	r24, Z
  d0:	48 2f       	mov	r20, r24
  d2:	8a 81       	ldd	r24, Y+2	; 0x02
  d4:	28 2f       	mov	r18, r24
  d6:	30 e0       	ldi	r19, 0x00	; 0
  d8:	81 e0       	ldi	r24, 0x01	; 1
  da:	90 e0       	ldi	r25, 0x00	; 0
  dc:	02 2e       	mov	r0, r18
  de:	00 c0       	rjmp	.+0      	; 0xe0 <DIO_voidTogglePinValue+0xe0>

				}
				else
				{
					SET_BIT(DDRB,Pin);
  e0:	88 0f       	add	r24, r24
  e2:	99 1f       	adc	r25, r25
  e4:	0a 94       	dec	r0
  e6:	02 f4       	brpl	.+0      	; 0xe8 <DIO_voidTogglePinValue+0xe8>
  e8:	84 27       	eor	r24, r20
  ea:	8c 93       	st	X, r24
  ec:	0f 90       	pop	r0
  ee:	0f 90       	pop	r0
  f0:	0f 90       	pop	r0
  f2:	0f 90       	pop	r0
  f4:	cf 91       	pop	r28
  f6:	df 91       	pop	r29
  f8:	08 95       	ret

Disassembly of section .text.DIO_u8GetPinValue:

00000000 <DIO_u8GetPinValue>:




void DIO_voidSetPinDir(u8 Port,u8 Pin,u8 Dir)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <DIO_u8GetPinValue+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <DIO_u8GetPinValue+0x8>
   8:	00 d0       	rcall	.+0      	; 0xa <DIO_u8GetPinValue+0xa>
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
   e:	89 83       	std	Y+1, r24	; 0x01
  10:	6a 83       	std	Y+2, r22	; 0x02
  12:	89 81       	ldd	r24, Y+1	; 0x01

switch(Port)
  14:	28 2f       	mov	r18, r24
  16:	30 e0       	ldi	r19, 0x00	; 0
  18:	3d 83       	std	Y+5, r19	; 0x05
  1a:	2c 83       	std	Y+4, r18	; 0x04
  1c:	4c 81       	ldd	r20, Y+4	; 0x04
  1e:	5d 81       	ldd	r21, Y+5	; 0x05
  20:	41 30       	cpi	r20, 0x01	; 1
  22:	51 05       	cpc	r21, r1
  24:	01 f0       	breq	.+0      	; 0x26 <DIO_u8GetPinValue+0x26>
  26:	8c 81       	ldd	r24, Y+4	; 0x04
  28:	9d 81       	ldd	r25, Y+5	; 0x05
  2a:	82 30       	cpi	r24, 0x02	; 2
  2c:	91 05       	cpc	r25, r1
  2e:	04 f4       	brge	.+0      	; 0x30 <DIO_u8GetPinValue+0x30>
  30:	2c 81       	ldd	r18, Y+4	; 0x04
  32:	3d 81       	ldd	r19, Y+5	; 0x05
  34:	21 15       	cp	r18, r1
  36:	31 05       	cpc	r19, r1
  38:	01 f0       	breq	.+0      	; 0x3a <DIO_u8GetPinValue+0x3a>
  3a:	00 c0       	rjmp	.+0      	; 0x3c <DIO_u8GetPinValue+0x3c>
  3c:	4c 81       	ldd	r20, Y+4	; 0x04
  3e:	5d 81       	ldd	r21, Y+5	; 0x05
  40:	42 30       	cpi	r20, 0x02	; 2
  42:	51 05       	cpc	r21, r1
  44:	01 f0       	breq	.+0      	; 0x46 <DIO_u8GetPinValue+0x46>
  46:	8c 81       	ldd	r24, Y+4	; 0x04
  48:	9d 81       	ldd	r25, Y+5	; 0x05
  4a:	83 30       	cpi	r24, 0x03	; 3
  4c:	91 05       	cpc	r25, r1
  4e:	01 f0       	breq	.+0      	; 0x50 <DIO_u8GetPinValue+0x50>
  50:	00 c0       	rjmp	.+0      	; 0x52 <DIO_u8GetPinValue+0x52>
  52:	e9 e3       	ldi	r30, 0x39	; 57
  54:	f0 e0       	ldi	r31, 0x00	; 0
  56:	80 81       	ld	r24, Z
{
	case 0:
		if(Dir==0)
  58:	28 2f       	mov	r18, r24
  5a:	30 e0       	ldi	r19, 0x00	; 0
  5c:	8a 81       	ldd	r24, Y+2	; 0x02
		{
			CLEAR_BIT(DDRA,Pin);
  5e:	88 2f       	mov	r24, r24
  60:	90 e0       	ldi	r25, 0x00	; 0
  62:	a9 01       	movw	r20, r18
  64:	00 c0       	rjmp	.+0      	; 0x66 <DIO_u8GetPinValue+0x66>
  66:	55 95       	asr	r21
  68:	47 95       	ror	r20
  6a:	8a 95       	dec	r24
  6c:	02 f4       	brpl	.+0      	; 0x6e <DIO_u8GetPinValue+0x6e>
  6e:	ca 01       	movw	r24, r20
  70:	58 2f       	mov	r21, r24
  72:	51 70       	andi	r21, 0x01	; 1
  74:	5b 83       	std	Y+3, r21	; 0x03
  76:	00 c0       	rjmp	.+0      	; 0x78 <DIO_u8GetPinValue+0x78>
  78:	e6 e3       	ldi	r30, 0x36	; 54
  7a:	f0 e0       	ldi	r31, 0x00	; 0
  7c:	80 81       	ld	r24, Z
  7e:	28 2f       	mov	r18, r24
  80:	30 e0       	ldi	r19, 0x00	; 0
  82:	8a 81       	ldd	r24, Y+2	; 0x02
  84:	88 2f       	mov	r24, r24
  86:	90 e0       	ldi	r25, 0x00	; 0

		}
		else
		{
			SET_BIT(DDRA,Pin);
  88:	a9 01       	movw	r20, r18
  8a:	00 c0       	rjmp	.+0      	; 0x8c <DIO_u8GetPinValue+0x8c>
  8c:	55 95       	asr	r21
  8e:	47 95       	ror	r20
  90:	8a 95       	dec	r24
  92:	02 f4       	brpl	.+0      	; 0x94 <DIO_u8GetPinValue+0x94>
  94:	ca 01       	movw	r24, r20
  96:	58 2f       	mov	r21, r24
  98:	51 70       	andi	r21, 0x01	; 1
  9a:	5b 83       	std	Y+3, r21	; 0x03
  9c:	00 c0       	rjmp	.+0      	; 0x9e <DIO_u8GetPinValue+0x9e>
  9e:	e3 e3       	ldi	r30, 0x33	; 51
  a0:	f0 e0       	ldi	r31, 0x00	; 0
  a2:	80 81       	ld	r24, Z
  a4:	28 2f       	mov	r18, r24
  a6:	30 e0       	ldi	r19, 0x00	; 0
  a8:	8a 81       	ldd	r24, Y+2	; 0x02
  aa:	88 2f       	mov	r24, r24
  ac:	90 e0       	ldi	r25, 0x00	; 0
  ae:	a9 01       	movw	r20, r18



		break;
	case 1:
		if(Dir==0)
  b0:	00 c0       	rjmp	.+0      	; 0xb2 <DIO_u8GetPinValue+0xb2>
  b2:	55 95       	asr	r21
  b4:	47 95       	ror	r20
				{
					CLEAR_BIT(DDRB,Pin);
  b6:	8a 95       	dec	r24
  b8:	02 f4       	brpl	.+0      	; 0xba <DIO_u8GetPinValue+0xba>
  ba:	ca 01       	movw	r24, r20
  bc:	58 2f       	mov	r21, r24
  be:	51 70       	andi	r21, 0x01	; 1
  c0:	5b 83       	std	Y+3, r21	; 0x03
  c2:	00 c0       	rjmp	.+0      	; 0xc4 <DIO_u8GetPinValue+0xc4>
  c4:	e0 e3       	ldi	r30, 0x30	; 48
  c6:	f0 e0       	ldi	r31, 0x00	; 0
  c8:	80 81       	ld	r24, Z
  ca:	28 2f       	mov	r18, r24
  cc:	30 e0       	ldi	r19, 0x00	; 0
  ce:	8a 81       	ldd	r24, Y+2	; 0x02
  d0:	88 2f       	mov	r24, r24
  d2:	90 e0       	ldi	r25, 0x00	; 0
  d4:	a9 01       	movw	r20, r18
  d6:	00 c0       	rjmp	.+0      	; 0xd8 <DIO_u8GetPinValue+0xd8>
  d8:	55 95       	asr	r21
  da:	47 95       	ror	r20
  dc:	8a 95       	dec	r24
  de:	02 f4       	brpl	.+0      	; 0xe0 <DIO_u8GetPinValue+0xe0>

				}
				else
				{
					SET_BIT(DDRB,Pin);
  e0:	ca 01       	movw	r24, r20
  e2:	58 2f       	mov	r21, r24
  e4:	51 70       	andi	r21, 0x01	; 1
  e6:	5b 83       	std	Y+3, r21	; 0x03
  e8:	00 c0       	rjmp	.+0      	; 0xea <DIO_u8GetPinValue+0xea>
  ea:	00 c0       	rjmp	.+0      	; 0xec <DIO_u8GetPinValue+0xec>
  ec:	8b 81       	ldd	r24, Y+3	; 0x03
  ee:	8e 83       	std	Y+6, r24	; 0x06
  f0:	8e 81       	ldd	r24, Y+6	; 0x06
  f2:	26 96       	adiw	r28, 0x06	; 6
  f4:	0f b6       	in	r0, 0x3f	; 63
  f6:	f8 94       	cli
  f8:	de bf       	out	0x3e, r29	; 62
  fa:	0f be       	out	0x3f, r0	; 63
  fc:	cd bf       	out	0x3d, r28	; 61
  fe:	cf 91       	pop	r28
 100:	df 91       	pop	r29
 102:	08 95       	ret

main.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000438  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      0000089f  00000000  00000000  0000046c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.main    0000008a  00000000  00000000  00000d0b  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.main:

00000000 <main>:
#include<avr/interrupt.h>
#include<util/delay.h>
#define F_CPU 12000000

int main(void)
{    //voltage divider
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <main+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <main+0x8>
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
	u16 digital,analog;
	DIO_voidSetPinDir(PORT_D,PIN_0,OUTPUT);
   c:	83 e0       	ldi	r24, 0x03	; 3
   e:	60 e0       	ldi	r22, 0x00	; 0
  10:	41 e0       	ldi	r20, 0x01	; 1
  12:	0e 94 00 00 	call	0	; 0x0 <main>
	DIO_voidSetPinDir(PORT_D,PIN_1,OUTPUT);
  16:	83 e0       	ldi	r24, 0x03	; 3
  18:	61 e0       	ldi	r22, 0x01	; 1
  1a:	41 e0       	ldi	r20, 0x01	; 1
  1c:	0e 94 00 00 	call	0	; 0x0 <main>
	ADC_voidInit();
  20:	0e 94 00 00 	call	0	; 0x0 <main>
	while(1)
	{
		ADC_voidSelectChannel(0);
  24:	80 e0       	ldi	r24, 0x00	; 0
  26:	0e 94 00 00 	call	0	; 0x0 <main>
		ADC_voidStartConversion();
  2a:	0e 94 00 00 	call	0	; 0x0 <main>
		digital=ADC_u16GetCurrentValue();
  2e:	0e 94 00 00 	call	0	; 0x0 <main>
  32:	9c 83       	std	Y+4, r25	; 0x04
  34:	8b 83       	std	Y+3, r24	; 0x03
		analog=(digital*5)/1024; //to be compatability
  36:	2b 81       	ldd	r18, Y+3	; 0x03
  38:	3c 81       	ldd	r19, Y+4	; 0x04
  3a:	c9 01       	movw	r24, r18
  3c:	88 0f       	add	r24, r24
  3e:	99 1f       	adc	r25, r25
  40:	88 0f       	add	r24, r24
  42:	99 1f       	adc	r25, r25
  44:	82 0f       	add	r24, r18
  46:	93 1f       	adc	r25, r19
  48:	89 2f       	mov	r24, r25
  4a:	99 27       	eor	r25, r25
  4c:	86 95       	lsr	r24
  4e:	86 95       	lsr	r24
  50:	9a 83       	std	Y+2, r25	; 0x02
  52:	89 83       	std	Y+1, r24	; 0x01
		if(analog>2)
  54:	89 81       	ldd	r24, Y+1	; 0x01
  56:	9a 81       	ldd	r25, Y+2	; 0x02
  58:	83 30       	cpi	r24, 0x03	; 3
  5a:	91 05       	cpc	r25, r1
  5c:	00 f0       	brcs	.+0      	; 0x5e <main+0x5e>
		{	DIO_voidSetPinValue(PORT_D,PIN_0,HIGH);
  5e:	83 e0       	ldi	r24, 0x03	; 3
  60:	60 e0       	ldi	r22, 0x00	; 0
  62:	41 e0       	ldi	r20, 0x01	; 1
  64:	0e 94 00 00 	call	0	; 0x0 <main>
			DIO_voidSetPinValue(PORT_D,PIN_1,LOW);
  68:	83 e0       	ldi	r24, 0x03	; 3
  6a:	61 e0       	ldi	r22, 0x01	; 1
  6c:	40 e0       	ldi	r20, 0x00	; 0
  6e:	0e 94 00 00 	call	0	; 0x0 <main>
  72:	00 c0       	rjmp	.+0      	; 0x74 <main+0x74>
		}
		else
		{	DIO_voidSetPinValue(PORT_D,PIN_0,LOW);
  74:	83 e0       	ldi	r24, 0x03	; 3
  76:	60 e0       	ldi	r22, 0x00	; 0
  78:	40 e0       	ldi	r20, 0x00	; 0
  7a:	0e 94 00 00 	call	0	; 0x0 <main>
			DIO_voidSetPinValue(PORT_D,PIN_1,HIGH);
  7e:	83 e0       	ldi	r24, 0x03	; 3
  80:	61 e0       	ldi	r22, 0x01	; 1
  82:	41 e0       	ldi	r20, 0x01	; 1
  84:	0e 94 00 00 	call	0	; 0x0 <main>
  88:	00 c0       	rjmp	.+0      	; 0x8a <__SREG__+0x4b>
